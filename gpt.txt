import json
from telegram import (
    Update,
    KeyboardButton,
    ReplyKeyboardMarkup,
    InlineKeyboardButton,
    InlineKeyboardMarkup,
)
from telegram.ext import ContextTypes
from database import get_db_connection
from utils import push_menu
import requests
from currencyapi import (
    three_month_price,
    six_month_price,
    twelve_month_price,
    update_data,
)
from texts import (
    BUY_PREMIUM_TEXT,
    BUY_FOR_SELF_TEXT,
    BUY_FOR_FRIENDS_TEXT,
    BUY_SUCCESS_TEXT,
    LOREM,
    FAQ_TEXT,
    MY_PURCHASES_TEXT,
    GO_BACK_TEXT,
    THREE_M_SUB_TEXT,
    SIX_M_SUB_TEXT,
    TWELVE_M_SUB_TEXT,
    PENDING_APPROVAL_TEXT,
    APPROVED_TEXT,
    CANCELLED_TEXT,
    REVIEWING_TEXT,
    CHOOSE_USERNAME_ERROR_TEXT,
    SUB_HELP_TEXT,
    WELCOME_TEXT,
    CHOOSE_OPTION_TEXT,
    INVALID_OPTION_TEXT,
    FAILED_UPDATE_STATUS_TEXT,
    ERROR_SENDING_PHOTO,
    UNKNOWN_TEXT,
    NO_SUB_TEXT,
)
from config import ADMIN_CHAT_ID
import uuid
from dbconn import conn, cur
from ridi import redis_conn


def set_session(user_id, key, value):
    session_key = f"user_session:{user_id}:{key}"
    redis_conn.set(session_key, value)

def get_session(user_id, key):
    session_key = f"user_session:{user_id}:{key}"
    return redis_conn.get(session_key)

def delete_session(user_id, key):
    session_key = f"user_session:{user_id}:{key}"
    redis_conn.delete(session_key)


def push_menu(user_id: str, menu_function):
    redis_conn.rpush(f"menu_stack:{user_id}", menu_function.__name__)


async def go_back(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = str(update.effective_user.id)
    menu_stack_key = f"menu_stack:{user_id}"

    if redis_conn.llen(menu_stack_key) > 0:
        menu_function_name = redis_conn.rpop(menu_stack_key)
        if menu_function_name:
            menu_function = globals().get(menu_function_name)
            if menu_function:
                await menu_function(update, context)
    else:
        await start(update, context)


async def add_user(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_data = update.effective_user
    user_id = str(user_data.id)  # Cast to string
    user_username = user_data.username
    user_first_name = user_data.first_name
    user_last_name = user_data.last_name

    # Check if the user already exists
    cur.execute("SELECT id FROM users WHERE id = %s", (user_id,))
    existing_user = cur.fetchone()

    if not existing_user:
        cur.execute(
            "INSERT INTO users (id, username, first_name, last_name) VALUES (%s, %s,%s,%s)",
            (user_id, user_username, user_first_name, user_last_name),
        )
        conn.commit()


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = str(update.effective_user.id)
    push_menu(user_id, start)
    update_data()

    start_keys = [
        [
            KeyboardButton(text=BUY_PREMIUM_TEXT),
            KeyboardButton(text=MY_PURCHASES_TEXT),
        ],
        [
            KeyboardButton(text=FAQ_TEXT),
        ],
    ]
    markup = ReplyKeyboardMarkup(start_keys, resize_keyboard=True)

    await context.bot.send_message(
        chat_id=update.effective_chat.id, text=WELCOME_TEXT, reply_markup=markup
    )


async def buy_sub(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = str(update.effective_user.id)

    buy_keys = [
        [KeyboardButton(text=BUY_FOR_SELF_TEXT)],
    ]
    markup = ReplyKeyboardMarkup(buy_keys, resize_keyboard=True, one_time_keyboard=True)

    await context.bot.send_message(
        chat_id=update.effective_chat.id,
        text=SUB_HELP_TEXT,
        reply_markup=markup,
    )
    set_session(user_id, "awaiting_username", "true")


async def handle_text_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = str(update.effective_user.id)
    text = update.message.text

    if get_session(user_id, "awaiting_username") == "true":
        if text == BUY_FOR_SELF_TEXT:
            user_data = update.effective_user
            username = user_data.username
            set_session(user_id, "entered_username", username)
            delete_session(user_id, "awaiting_username")
            await subs_list(update, context)  # Proceed to the subscription list
        else:
            set_session(user_id, "entered_username", text)
            delete_session(user_id, "awaiting_username")
            await subs_list(update, context)  # Proceed to the subscription list
    else:
        # Handle other text messages here
        pass


async def subs_list(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = str(update.effective_user.id)
    push_menu(user_id, buy_sub)

    subs_list_keys = [
        [
            InlineKeyboardButton(text=THREE_M_SUB_TEXT, callback_data="sub:3m"),
        ],
        [
            InlineKeyboardButton(text=SIX_M_SUB_TEXT, callback_data="sub:6m"),
        ],
        [
            InlineKeyboardButton(text=TWELVE_M_SUB_TEXT, callback_data="sub:12m"),
        ],
    ]
    markup = InlineKeyboardMarkup(subs_list_keys)

    await context.bot.send_message(
        chat_id=update.effective_chat.id, text=CHOOSE_OPTION_TEXT, reply_markup=markup
    )
    print("Subs list sent with buttons: ", subs_list_keys)  # Debugging line


async def handle_sub_choice(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = str(update.effective_user.id)
    query = update.callback_query
    await query.answer()
    data = query.data

    print(f"Received callback data: {data}")  # Debugging line

    if data == "sub:3m":
        set_session(user_id, "sub_choice", THREE_M_SUB_TEXT)
        set_session(user_id, "sub_price", str(three_month_price))  # Store as string
    elif data == "sub:6m":
        set_session(user_id, "sub_choice", SIX_M_SUB_TEXT)
        set_session(user_id, "sub_price", str(six_month_price))  # Store as string
    elif data == "sub:12m":
        set_session(user_id, "sub_choice", TWELVE_M_SUB_TEXT)
        set_session(user_id, "sub_price", str(twelve_month_price))  # Store as string
    else:
        print(INVALID_OPTION_TEXT)  # Debugging line
        await query.edit_message_text(text=INVALID_OPTION_TEXT)
        return

    await buy_for_self(update, context)


async def buy_for_self(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = str(update.effective_user.id)
    push_menu(user_id, subs_list)

    user_data = (
        update.callback_query.from_user
        if update.callback_query
        else update.message.from_user
    )

    invoice_title = get_session(user_id, "sub_choice")
    invoice_price = get_session(user_id, "sub_price")

    if not invoice_title or not invoice_price:
        await context.bot.send_message(chat_id=update.effective_chat.id, text="خطا")
        return

    # Check if the username was entered earlier; if not, use the Telegram username
    username = get_session(user_id, "entered_username")
    if not username:
        username = user_data.username
    else:
        # Clear the custom username after using it
        delete_session(user_id, "entered_username")

    invoice_description = f"@{username} اشتراک یک ماهه برای نام کاربری"

    # Process the invoice creation
    invoice_details = {
        "title": invoice_title,
        "description": invoice_description,
        "price": invoice_price,
    }

    set_session(user_id, "invoice_details", json.dumps(invoice_details))

    # Send the invoice or next steps here
    await context.bot.send_message(
        chat_id=update.effective_chat.id,
        text=f"""**Invoice**

Title: {invoice_title}
Description: {invoice_description}
Price: {invoice_price} ت

Please wait while we process your subscription.""",
    )


async def update_status(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    data = query.data.split(":")
    invoice_id = data[1] if len(data) > 1 else None
    new_status = data[2] if len(data) > 2 else None

    if invoice_id and new_status:
        try:
            # Update the status in the database
            cur.execute(
                "UPDATE invoice SET status = %s WHERE invoice_id = %s",
                (new_status, invoice_id),
            )
            conn.commit()

            # Get the existing caption
            existing_caption = query.message.caption if query.message.caption else ""

            # Append the status update to the existing caption
            updated_caption = f"{existing_caption}\n\nUpdated status to: {new_status}"

            # Determine the new inline buttons based on the new status
            if new_status == "Pending Approval":
                inline_keyboard = [
                    [
                        InlineKeyboardButton(
                            text=REVIEWING_TEXT,
                            callback_data=f"update_status:{invoice_id}:reviewing",
                        ),
                        InlineKeyboardButton(
                            text=APPROVED_TEXT,
                            callback_data=f"update_status:{invoice_id}:approved",
                        ),
                        InlineKeyboardButton(
                            text=CANCELLED_TEXT,
                            callback_data=f"update_status:{invoice_id}:cancelled",
                        ),
                    ]
                ]
            elif new_status == "Approved":
                inline_keyboard = [
                    [
                        InlineKeyboardButton(
                            text=PENDING_APPROVAL_TEXT,
                            callback_data=f"update_status:{invoice_id}:pending_approval",
                        ),
                        InlineKeyboardButton(
                            text=REVIEWING_TEXT,
                            callback_data=f"update_status:{invoice_id}:reviewing",
                        ),
                        InlineKeyboardButton(
                            text=CANCELLED_TEXT,
                            callback_data=f"update_status:{invoice_id}:cancelled",
                        ),
                    ]
                ]
            elif new_status == "Cancelled":
                inline_keyboard = [
                    [
                        InlineKeyboardButton(
                            text=PENDING_APPROVAL_TEXT,
                            callback_data=f"update_status:{invoice_id}:pending_approval",
                        ),
                        InlineKeyboardButton(
                            text=REVIEWING_TEXT,
                            callback_data=f"update_status:{invoice_id}:reviewing",
                        ),
                        InlineKeyboardButton(
                            text=APPROVED_TEXT,
                            callback_data=f"update_status:{invoice_id}:approved",
                        ),
                    ]
                ]
            else:
                inline_keyboard = [
                    [
                        InlineKeyboardButton(
                            text=PENDING_APPROVAL_TEXT,
                            callback_data=f"update_status:{invoice_id}:pending_approval",
                        ),
                        InlineKeyboardButton(
                            text=APPROVED_TEXT,
                            callback_data=f"update_status:{invoice_id}:approved",
                        ),
                        InlineKeyboardButton(
                            text=CANCELLED_TEXT,
                            callback_data=f"update_status:{invoice_id}:cancelled",
                        ),
                    ]
                ]

            # Edit the message caption and inline buttons
            await query.edit_message_caption(
                caption=updated_caption,
                reply_markup=InlineKeyboardMarkup(inline_keyboard),
            )
        except Exception as e:
            print(f"Failed to update status: {str(e)}")
            await query.edit_message_text(text=FAILED_UPDATE_STATUS_TEXT)
    else:
        await query.edit_message_text(text=INVALID_OPTION_TEXT)


async def faq(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await context.bot.send_message(chat_id=update.effective_chat.id, text=FAQ_TEXT)


async def my_purchases(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = str(update.effective_user.id)
    try:
        # Fetch user's purchases from the database
        cur.execute("SELECT * FROM purchases WHERE user_id = %s", (user_id,))
        purchases = cur.fetchall()

        if purchases:
            for purchase in purchases:
                purchase_info = f"Purchase ID: {purchase[0]}\nUsername: {purchase[1]}\nSubscription: {purchase[2]}\nStatus: {purchase[3]}"
                await context.bot.send_message(
                    chat_id=update.effective_chat.id, text=purchase_info
                )
        else:
            await context.bot.send_message(
                chat_id=update.effective_chat.id, text="No purchases found."
            )
    except Exception as e:
        await context.bot.send_message(
            chat_id=update.effective_chat.id, text=f"An error occurred: {str(e)}"
        )
